"EXAMPLE:";  
//echo = 2;
LIB "latex.lib";
LIB "brnoeth.lib";
LIB "matrix.lib";
//int plevel=printlevel;
//printlevel=-1;
int pchar=13;
ring s=pchar,(x,y),lp;
list HC=Adj_div(x3+y2+y);
print(HC);
HC=NSplaces(1..2,HC);
print(HC);
HC=extcurve(2,HC);
print(HC);
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// let us construct the corresponding evaluation AG code :
matrix C=AGcode_L(G,D,HC);
// here is a linear code of type [8,5,>=3] over F_4
print(C);
texobj("",C);

//printlevel=plevel;

proc Ker (matrix A)
{
//
//  Returns a matrix M such that A*M^T=0.
//
  // warning : "lp" ordering is necessary
  intvec opgt=option(get);
  option(redSB);
  matrix M=transpose(syz(A));
  option(set,opgt);
  return(M);
}


proc IntersectAandB(matrix C, matrix C_Perp_H)
{
//
//  Let <M> be a vector space spanned by the rows of a matrix M.
//  Calculates the vector space that is the intersection of <A> and <B>.
//  The result is a matrix MR, such that <MR>= Intersection(<A>,<B>).
//
//  The algorithm is as follows.
//  Solve v*[A, -B]=0, where v=[vA,vB]^T such that vA^T*A=vB^T*B.
//  vA^T*A or vB^T*B is the intersection.
//  Equivalently, we solve
// 
//  ||  A^T || 
//  ||      ||  *  x = 0, where x=[x_A, x_B].
//  || -B^T ||
//    
//  The intersection is (A^T*x_A)^T or (B^T*x_B)^T.
//   
//
 matrix MAB=concat(transpose(C),-transpose(C_Perp_H));
 matrix KerMAB=Ker(MAB);
 matrix MA=submat(KerMAB,1..nrows(KerMAB),1..nrows(C));
 matrix MB=submat(KerMAB,1..nrows(KerMAB),nrows(C)+1..nrows(C_Perp_H)+nrows(C));
 return (transpose(transpose(C)*transpose(MA)));
// return (transpose(transpose(C_Perp_H)*transpose(MB)));
}


proc Vprod(A,B)
{
  //
  // Calculates (A,\bar{B})
  //
	int q;
	matrix BP[nrows(B)][ncols(B)];
	for (q=1;q<=ncols(A);q=1+q)
	{
	  BP[1,q]=(B[1,q])^char(basering);
	}
	return (A*transpose(BP));
}

proc MCONJG(B)
{
//
//  Caluculates a new matrix whose entries are the conjugates of those in the matrix B.
//
  matrix BP[nrows(B)][ncols(B)];
  int l,m;
  for (l=1;l<=nrows(B);l=1+l)
  {
    for (m=1;m<=ncols(B);m=1+m)
    {
      BP[l,m]=(B[l,m])^char(basering);
    }
  }
  return (BP);
}

matrix CP[nrows(C)][ncols(C)];

print("Compute (C[][])^P");
int i,j;
for (i=1;i<=nrows(CP);i=i+1){
    for (j=1;j<=ncols(CP);j=j+1){
        CP[i,j]=(C[i,j]^char(basering))*number(1);
    }
}
print("");
print(CP);texobj("",CP);
print("");
print(MCONJG(C));texobj("",MCONJG(C));

print("Compute C_Perp_H, the vector space h-perpendicular to C, the classical linear code.");
matrix C_Perp_H=Ker(CP);
print(C_Perp_H);texobj("",C_Perp_H);

matrix MAB=concat(transpose(C),-transpose(C_Perp_H));
print("MAB:= Concat_rows(C^T, C_Perp_H^T)");
print(MAB);texobj("",MAB);
matrix KerMAB=Ker(MAB);
print("Ker(MAB)");
print(KerMAB);texobj("",KerMAB);

intvec r1=1..nrows(KerMAB);
intvec v1=1..nrows(C);
intvec v2=nrows(C)+1..nrows(C_Perp_H)+nrows(C);

matrix MA=submat(KerMAB,1..nrows(KerMAB),1..nrows(C));
matrix MB=submat(KerMAB,1..nrows(KerMAB),nrows(C)+1..nrows(C_Perp_H)+nrows(C));

print("C");
print(C);texobj("",C);
print("Compute r(M), the intersection of C and C_Perp_H");
matrix IntersectCCPH=transpose(transpose(C)*transpose(MA));
print(IntersectCCPH);texobj("",IntersectCCPH);
print("Computed in another way.");
print(transpose(transpose(C_Perp_H)*transpose(MB)));texobj("",transpose(transpose(C_Perp_H)*transpose(MB)));
print("Computed by a subroutine.");
print(IntersectAandB(C, C_Perp_H));texobj("",IntersectAandB(C, C_Perp_H));


///////////////////////////////////////////////////////////////////////////////
proc supplement (matrix W,matrix V)
"USAGE:     supplement(W,V), where W,V are matrices of numbers such that the
            vector space generated by the rows of W is contained in that
            generated by the rows of V
RETURN:     matrix whose rows generate a supplementary vector space of W in V,
            or a zero row-matrix if <W>==<V>
NOTE:       W,V must be given with maximal rank
"
{
  // W and V represent independent sets of vectors and <W> is assumed to be
  // contained in <V>
  // computes matrix S whose rows are l.i. vectors s.t. <W> union <S> is a
  // basis of <V>
  // careful : the size of all vectors is assumed to be the same but it is
  //  not checked and neither the linear independence of the vectors is checked
  // the trivial case W=0 is not covered by this procedure (and thus V<>0)
  // if <W>=<V> then a zero row-matrix is returned
  // warning : option(redSB) must be set in advance
  int n1=nrows(W);
  int n2=nrows(V);
  //print("W");print(W);
  //print("V");print(V);
  int s=n2-n1;
  if (s==0)
  {
    int n=ncols(W);
    matrix HH[1][n];
    return(HH);
  }
  matrix H=transpose(lift(transpose(V),transpose(W)));
  //print("H");print(H);
  H=supplem(H);
  //print("H");print(H);
  return(H*V);
}
///////////////////////////////////////////////////////////////////////////////
proc supplem (matrix M)
"USAGE:      supplem(M), where M is a matrix of numbers with maximal rank
RETURN:     matrix whose rows generate a supplementary vector space of <M> in
            k^n, where k is the base field and n is the number of columns
SEE ALSO:   supplement
NOTE:       The rank r is assumed to be 1<r<n.
"
{
  // warning : the linear independence of the rows is not checked
  int r=nrows(M);
  int n=ncols(M);
  int s=n-r;
  matrix A=M;
  matrix supl[s][n];
  int counter=0;
  int h=r+1;
  int i;
  for (i=1;i<=n;i=i+1)
  {
    matrix TT[1][n];
    TT[1,i]=1;
    A=transpose(concat(transpose(A),transpose(TT)));
    r=mat_rank(A);
    if (r==h)
    {
      h=h+1;
      counter=counter+1;
      supl=transpose(concat(transpose(supl),transpose(TT)));
      if (counter==s)
      {
        break;
      }
    }
    kill TT;
  }
  supl=transpose(compress(transpose(supl)));
  return(supl);
}
///////////////////////////////////////////////////////////////////////////////
proc mat_rank (matrix A)
{
  // warning : "lp" ordering is necessary
  intvec opgt=option(get);
  option(redSB);
  int r=size(std(module(transpose(A))));
  option(set,opgt);
  return(r);
}
///////////////////////////////////////////////////////////////////////////////

print("Compute r(B),such that the union of r(B) and r(A) is <C>, the classical linear code.");
print(supplement(IntersectCCPH,C));texobj("",supplement(IntersectCCPH,C));


proc iterator(int n, int p, int nd)
{
    ring ri=0,(T),lp;
    setring ri;
    int ns=n;
    int res=ns % p;
    int ic=0;
    int isum=0;
    list iv;
    list ir=res;
    while (n >=p^ic )
    {
        ns = ns-res;
        ns = ns div p;
        res= ns % p;
        //print(res);
        ic=ic+1;
        //print(ic);
        //print(p^ic);
        iv=res,ic,n,p^ic;
        //print(iv);
        ir=insert(ir,res);
    }
    list irf;
    int i;
    for (i=1;i<=nd;i=1+i)
    {
        irf=insert(irf,0);
    }
    for (i=2;i<=size(ir);i=1+i)
    {
        irf[i-1]=ir[i];
    }
    kill ri;
    return(irf);
}

proc pq(number q)
{
    number qn=q;
    print(qn);
}
proc FindOrderN(number q)
{
    int l=1;
    number qn=q;
    int ic=0;
    while(l<1000000)
    {
        if (qn == number(1))
        {
            break;
        }
        qn = qn*q;
        l=1+l;
    }
    return(l);
}

int l,m,q;
list iv;
number qr;
print("Search the generating element(s) of F_{p^2}\{0}");
list genelem;
list MaximalOrderE;
for (l=0;l<char(basering);l=1+l)
{
    for (m=0;m<char(basering);m=1+m)
    {
        if (l+m>=1){
        qr=l+m*a;
        iv=qr,FindOrderN(qr);
        if (FindOrderN(qr)==char(basering)^2-1){genelem=insert(genelem,qr);}
        }
    }
}

print(genelem);texobj("",genelem);


print("Compute the subspace that should be refined to r(B): (C_Perp_H \\ r(M))");
print(supplement(IntersectCCPH,C_Perp_H));texobj("",supplement(IntersectCCPH,C_Perp_H));
matrix ISV=supplement(IntersectCCPH,C_Perp_H); 
// ISV is the the basis of r(B); Rows of r(B) are not orthogonal among themselves,
// In addition rows of r(B) are not perpendicular to r(M).


matrix V1[1][ncols(ISV)];
matrix V2[1][ncols(ISV)];
matrix VC[1][ncols(ISV)];
matrix VC1[1][ncols(ISV)];
matrix VC2[1][ncols(ISV)];
for (l=1;l<=ncols(ISV);l=1+l){V1[1,l]=ISV[1,l];V2[1,l]=ISV[2,l];}




proc MakeLengthOne(matrix M)
{
 int l,m;
 //print("---MakeLengthOne---");
 //print(M);
 number cv;
 matrix NR,VC;
 list cvone;
 for (l=0;l<char(basering);l=1+l)
 {
  for (m=0;m<char(basering);m=1+m)
	{
		cv=l+a*m;
		VC=cv*M;
		NR=Vprod(VC,VC);
		if (NR[1,1]==a^0)
    {
		 cvone=insert(cvone,cv);
    }
	}
 }
 return(M*cvone[1]);
}

proc GRAMSCHMIDT(matrix M)
{
//  print("---GRAMSCHMIDT---");
//  print(M);
//   Task:
//     Let <M> be a vector space spanned by the rows of a matrix M. 
//     This function makes a vector v and a matrix MR from <M>. 
//     such that (v,\bar{v})==1; 
//     the vectors in <MR> are perpendicular to the vector v;
//     The union of <[v]> and <MR> is equal to <M>.
//   One should use this function recursively to get an orthogonal base of <M>.
//
// Find two vectors such that (x,y)!=0.  
  int nr=nrows(M);
  int nc=ncols(M);
  matrix V1[1][nc];
  matrix V2[1][nc];
  matrix VC[1][nc];
  matrix CP[1][nc];
  matrix SUP;
  matrix SUP_P;
  list cvone;
  number cv;
  matrix NR;
  list RV1;
  list ret_val;
  int l,m;
  int i,j,k;
  matrix V12;
//
//  V1:=x; V2:=y;
//
  if (nr==1)
  {
   for (k=1;k<=nc;k=k+1)
      {
        V1[1,k]=M[1,k];
        V2[1,k]=M[1,k];
      }
  }

  if (nr>=2)
  {  
   for (i=1;i<=nr-1;i=i+1)
   {
    for (j=i+1;j<=nr;j=j+1)
    {
      for (k=1;k<=nc;k=k+1)
      {
        V1[1,k]=M[i,k];
        V2[1,k]=M[j,k];
      }
      V12=Vprod(V1,V2);
      if (V12[1,1]!=0*a)
      {
        break;
      }
    }
   }
  }

//
//Find an element such that (x+c*y,x*c*y)==1/
//
  for (l=0;l<char(basering);l=1+l)
  {
    for (m=0;m<char(basering);m=1+m)
	  {
	    cv=l+a*m;
 	    VC=V1+cv*V2;
 	    NR=Vprod(VC,VC);
	    if (NR[1,1]==a^0){
       cvone=insert(cvone,cv);
      }
    }
  }



//
// VC := x+c*y.
//
 cv=cvone[1];
 VC=V1+cv*V2;

//
// <SUP> is the complement of <VC> in <M>.
//
 SUP=supplement(VC,M);

//
// Remakes <SUP> into <SUP_P> 
// so that the vectors {w} in <SUP_P> are perpeldicular to x+c*y,
// in such a way that (w,\bar{x+c*y})=0
//
 SUP_P=SUP-Vprod(SUP,VC)*VC;
 ret_val=VC,SUP_P;
 return (ret_val);
 if (nr==1)
 {
  print("nr==1");
  matrix MR=MakeLengthOne(M);
  print(MR);
  for (int nn=1;nn<=nc;nn=nn+1)
  {
    print("");
    print(MR[1,nn]);
    print(VC[1,nn]);
    if (VC[1,nn]!= 0*a)
    {
      print(MR[1,nn]/VC[1,nn]);
    }
  }
 }
 return(ret_val);
}



list GR=GRAMSCHMIDT(ISV);
print("GRAMSCHMIDT");
print(GR);
texobj("",GR[1]);texobj("",GR[2]);
print("MakeLengthOne");
print(MakeLengthOne(GR[2]));

list GR2=GRAMSCHMIDT(GR[2]);
print("GRAMSCHMIDT");
print(GR2);
texobj("",GR2[1]);texobj("",GR2[2]);


//print(GR[1]);
//print(GR2[1]);
//print(-GR2[1]);
//print(Vprod(GR[1],GR[1]));
//print(Vprod(GR[1],GR2[1]));
//print(Vprod(GR2[1],GR[1]));
//print(Vprod(GR2[1],GR2[1]));



matrix WC=ISV;
int nrowdim=nrows(WC);
list GRWC;
print("GR process");
matrix rB;
while(nrowdim>0)
{
 GRWC=GRAMSCHMIDT(WC);
 WC=GRWC[2];
 print(WC);
 rB=transpose(concat(transpose(rB),transpose(GRWC[1])));
 nrowdim=mat_rank(WC);
 print(nrowdim);
}

print("matrix r(B)");print(rB);texobj("",rB);
rB=submat(rB,2..nrows(rB),1..ncols(rB));
print("matrix r(B) [The top zero row is removed!]");print(rB);texobj("",rB);


print("r(A)");
print(IntersectCCPH);texobj("",IntersectCCPH);
print("r(M)");
print(supplement(IntersectCCPH,C));texobj("",supplement(IntersectCCPH,C));
print("r(B)");
print(rB);texobj("",rB);

print("Seek an element z such that z*\bar(z)==-1; this z is placed on the diagonal part of the submatrix at the right side of r(B)");
for (l=0;l<char(basering);l=1+l)
{
    for (m=0;m<char(basering);m=1+m)
    {
        qr=l+m*a;
        if (qr^(1+char(basering))==-1){print(qr);}        
    }
}
quit;
print("ORTHONORMAL BASE OF r(B)");

number cv;
matrix Vp;
matrix NR;
list RV1;
matrix CP[1][ncols(ISV)];
print("CHOSE X,Y, and Z(cv)=X+cv*Y such that <x,y> !=0 and ||Z(cv)||==1 ");

print("Is it true that <x,y> !=0?");
print("Affirm that in the matrix (x,y)^T*(CONJ{x},CONJ{y}), off-diagonal elements are not zero!");
print(ISV*transpose(MCONJG(ISV)));

list cvone;
for (l=0;l<char(basering);l=1+l)
{
    for (m=0;m<char(basering);m=1+m)
	{
	   cv=l+a*m;
	   VC=V1+cv*V2;
	   NR=Vprod(VC,VC);
	   RV1=cv,NR[1,1];
	   if (NR[1,1]==a^0){
	   print(RV1);print(VC);supplement(VC,ISV);cvone=insert(cvone,cv);}
	}
}

cv=cvone[1];
VC1=V1+cv*V2;
print("List of cv such that ||Z(cv)||==1");
print(cvone);
print(VC1);
print(Vprod(VC1,VC1));

print("---");
list cvone2;

matrix SUP[1][ncols(VC1)];
SUP=supplement(VC1,ISV);

print("Get the basis of r(B)\\VC1");
print("Checks whether r(B)\\VC1 is perpendicular to VC1...");
print(Vprod(VC1,SUP));
print("In general, r(B)\\VC1 is not perpendicular to VC1");
print("Then we must correct it: for v in r(B)\\C1, v -> v -  (v, C1)C1");


print("List of cv such that ||Z(cv)||==1");
print("VC2");
VC2=SUP-Vprod(SUP,VC1)*VC1;
print(VC2);
print("SUP");
print(SUP);
print("(vC2,VC2)");
print(Vprod(VC2,VC2));
print("(VC1,VC1)");
print(Vprod(VC1,VC1));
print("(VC1,VC2)");
print(Vprod(VC1,VC2));
print("(VC2,VC1)");
print(Vprod(VC2,VC1));

print("Normalize VC2");
for (l=0;l<char(basering);l=1+l)
{
    for (m=0;m<char(basering);m=1+m)
	{
		cv=l+a*m;
		VC=cv*VC2;
		NR=Vprod(VC,VC);
		RV1=cv,NR[1,1];
		if (NR[1,1]==a^0){
		print(RV1);print(VC);cvone2=insert(cvone2,cv);}
		}
		}
print("- - -");
VC2=VC2*cvone2[1];
print("(vC2,VC2)");
print(Vprod(VC2,VC2));
print("(VC1,VC1)");
print(Vprod(VC1,VC1));
print("(VC1,VC2)");
print(Vprod(VC1,VC2));
print("(VC2,VC1)");
print(Vprod(VC2,VC1));
//quit;


		